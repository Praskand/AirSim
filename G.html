<!DOCTYPE html>
<html> <head> <link rel="icon" type="image/x-icon" href=
    "https://avatars.githubusercontent.com/u/95966972?v=4">
    <title>G</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<style> :root {color-scheme: dark
    /* --h: calc(16px*30); --w: calc(var(--h)/(1+1/var(--i))); --i: 3; */
   }
/* .square {
  height: var(--h);
  width: calc(var(--w));
  border: 1px solid rgb(255, 0, 0);
  text-align: center; */
  /* 9/16 */
  /* background-color: #555; */
/* } */
/* .lb { position:relative;
  height: var(--h);
  width: calc(var(--w));
  border-top: 1px solid rgb(255, 0, 0);
  transform: rotate(45deg);
  transform-origin: 0% 0%;
}
.lu { position:absolute;
  height: var(--h);
  width: calc(var(--w));
  border-bottom: 1px solid rgb(255, 0, 0);
  transform: rotate(-45deg);
  transform-origin: 0% 0%;
}
.lm { position:absolute;
  height: var(--h);
  width: calc(var(--w));
  border-top: 1px solid rgb(255, 0, 0);
  transform: translate(0, calc(var(--h)/2));
}
.lc { position:absolute;
  height: var(--h);
  width: calc(var(--w));
  border-left: 1px solid rgb(255, 0, 0);
  transform: translate(calc(var(--w)/2));
} */
</style> </head>

<body> <script> console.clear(), sh = window.innerHeight, i = 3, wf = (1+1/i), sw = sh/wf
hf = 5/8, h = sh*hf
// 500
w = h/wf, g = (1-hf)*sh/2, r = sw/40, lg = (1-hf)*sw/2, rc = (1+hf)*sw/2, bes = sh - g/2 - 40
sca = 4 // up-pl
cly = (13/2 + 5)*sca, yc = g/2 - cly
// `<g stroke="grey" stroke-width="4" fill="black"> <circle cx="${lg + 40}" cy="${g/2}" r="40"/>
//      <circle cx="${vr}" cy="${g/2}" r="40"/>
//     <circle cx="${sw/2}" cy="${g/2}" r="40"/> </g>`
// Prefilled 2D-Array:
ar = (r, c) => Array(r).fill().map(() => Array(c).fill(0)), z = [0, 0]
ve = { u: 0, 'l': z, 'm': z, 'r': z
  // , v: 'lmr'
}
ul = { o: 'up', p: ' > path', i: 'ul', c: 'grey', ...ve
// object ,'doStuff': function() {
//     alert(this.a + this.b); }
}, ll = { o: 'dn', p: ' > rect', i: 'll', c: 'yellow', ...ve }, d = document

l = (y, l) => `<g id = '${l.i}' stroke="" stroke-linecap="round" stroke-linejoin="round"
stroke-width="1">
  <path id='l' d="M${lg + 40} ${y}h${w/2 - 40}"/> <path id='r' d="M${sw/2 + 1} ${y}h${w/2 - 40}"/>
  </g>`

  if (Math.round(Math.random())) {li = ll} else {li = ul}
cen = sw/2 - 40, t = g - 40, tcx = [lg-3*(sca-1), sw/2-(18/2+3)*sca, rc - 22*sca]
wh = `width="80" height="80"`, lol = sh - g - 40, m = sh/2 - 40, vl = lg - 40, vr = rc - 40
xco = (l, m, r) => [l - 40, m, r + 40], trcx = xco(tcx[0], tcx[1], tcx[2]), rb = rc - 80
// trbx = xco(lg, cen, rb)
trcy = [g, sh/2, sh - g].map(e => e - cly - sca)
// console.log('trcy, g',trcy, g)
// <g id = 'up'> </g>
// <g id='dn' > </g> 

c = (x, i) => `<path class='up' transform="translate(${x}, ${yc}) scale(${sca})" id = '${i}'
stroke="grey" fill="black" stroke-linecap="round" stroke-linejoin="round"
stroke-width="1"d="M3 13.6493C3 16.6044
5.41766 19 8.4 19L16.5 19C18.9853 19 21 16.9839 21 14.4969C21 12.6503
  19.8893 10.9449 18.3 10.25C18.1317 7.32251 15.684 5 12.6893 5C10.3514 5 8.34694 6.48637 7.5
  8.5C4.8 8.9375 3 11.2001 3 13.6493Z"/>`, dq = x => d.querySelector(x)
ye = (x, i) => `<rect class='dn' id='${i}' stroke = "yellow" style="opacity:1.0000000;
fill:green; fill-opacity:1.0000000;fill-rule:evenodd;
      stroke-width:4.0000000;stroke-linecap:round;stroke-linejoin:round;
      stroke-miterlimit:4.0000000;
      stroke-dasharray:none;stroke-dashoffset:0.00000000;stroke-opacity:1.0000000" x="${x}"
      y="${bes}" ${wh}/>`

str = (s = '') => {el.setAttribute('stroke', s)}, modo = q => d.querySelectorAll(q), mou = 'mouse'

move = (l) => { el = dq('#' + l.i), str(l.c)
// Add an abortable event listener
controller = new AbortController();
msi = { signal: controller.signal }
    // console.log('controller', controller)
    // This handler will be executed only once when the cursor
// moves over
modo('.' + li.o).forEach( e => { e.addEventListener(
  mou+"enter", (
  // event
) => {
    // mouseenter target event
    str()

    // reset the color after a short delay
  //   setTimeout(() => {
  //     event.target.style.color = ""
  //   }, 500)
  }, msi
  // ,false,
)

// Briefly, when the mouse moves off the element
e.addEventListener(
  mou + "leave", (
  // event
) => {
    // mouseleave target
    str(l.c)
  }, msi ) } ) }
// fill = "transparent"
s = d.body.innerHTML += `<center> <svg viewBox = '0 0 ${sw} ${sh}' height = ${sh
  } style=" position: absolute; top:0; bottom: 0; left: 0; right: 0;

    margin: auto;"> ${l(g/2, ul)}` +

  `<g transform="translate(${lg}, ${g})" stroke = "red">
    <path id='0' class='0' d="M0 0h${w}"/> <path id='infinity' class='2' d="M${w} 0v${h}"/>
    <path id='0' class='2' d="M${w} ${h}H0"/>
    <path id='infinity' class='0' d="M0 0v${h}"/>
    <path id='-' d="M0 0l${w} ${h}"/>
    <path id='+' d=" M0 ${h}L${w} 0"/>
    <path id='infinity' class='1' d="M${w/2} 0v${h}"/>
    <path id='0' class='1' d="M0 ${h/2}h${w}"/>
    <path d="M0 0h${r} A${r} ${r}, 0, 0, 1, 0 ${r}z M0 ${h} h${r} a${r} ${r}, 0, 0, 0, ${-r} ${-r
    }z M${w} 0 v${r} a${r} ${r}, 0, 0, 1, ${-r} ${-r}z M${w} ${h} v${-r} a${r} ${r}, 0, 0, 0, ${-r
    } ${r}z" fill = "black"/>
    <circle cx="${w/2}" cy="${h/2}" r="40" fill="black"/>
    <circle cx="${w/2}" cy="${h/2}" r="4" fill="red"/> </g> ${l(sh - g/2, ll)}` +

    `<g fill="transparent" id ='tr'>
      <rect x="${vl}" y="${t}" ${wh} id ='00'/>
      <rect x="${vr}" y="${t}" ${wh} id ='20'/>
      <rect x="${cen}" y="${t}" ${wh} id ='10'/>
      <rect x="${vl}" y="${m}" ${wh} id ='01'/>
      <rect x="${vr}" y="${m}" ${wh} id ='21'/>
      <rect x="${cen}" y="${m}" ${wh} id ='11'/>
      <rect x="${vl}" y="${lol}" ${wh} id ='02'/>
      <rect x="${vr}" y="${lol}" ${wh} id ='22'/>
      <rect x="${cen}" y="${lol}" ${wh} id ='12'/> </g>` +

`${c(tcx[0], 'l')} ${c(tcx[2], 'r')} ${c(tcx[1], 'm')}` +

  `${ye(lg, 'l')} ${ye(rb, 'r')} ${ye(cen, 'm')} </svg> </center>`
    move(li)

setAttributes = (el, attrs) => {
  for(var key in attrs) {
    el.setAttribute(key, attrs[key]); } }, gat = (el, x) => el.getAttribute(x)

eap = (el) => {dq('svg').append(el
// dq('.' + li.o)
)}
// check collinearity with area of triangle
(li) => { if (li.u == 2) if (!(li['l'][0]*(li['m'][1] - li['r'][0]) -
  li['l'][1]*(li['m'][0] - 1) + li['m'][0] - li['r'][1]))
  Math.atan((li['m'][1] - li['r'][1]) / (li['m'][0] - li['r'][0])) == 0 }

trf = (tre, el
  // event
  // , callback fn
) => {
  // tre = event.currentTarget.tre
  // console.log('li2', li, el, tre, k)
i = tre.id
// console.log('li3', li, el, k)

  x = +i[0], y = +i[1], t = arr[x][y]; if (!t) { 
  nto(li, () => { if (el.id  != 'm') { k = `#${li.i}`; if (!li.u) k += ` > #${el.id}`
  dq(k).remove() } li.u++ } ); if (li.o == 'up') {
  if (y == 2)  eap(el)
// console.log('liu', li, el, k)
    el.setAttribute('transform', `translate(${trcx[x]}, ${trcy[y]}) scale(${sca})`)
    li[el.id] = [x, y], li = ll, arr[x][y] = 1 }

else {
  if (y == 0) eap(el)
  // console.log('lid', li, el, k)
  setAttributes(el, {'x': `${gat(tre, 'x')}`, 'y': `${gat(tre, 'y')}`}), li[el.id] = [x, y], li = ul
  arr[x][y] = 2 }

  nto(li, () => { move(li) } )
// contp.abort(),
cont.abort(), rou()
  } }

  nto = (li, a = () => {}, e = () => {}) => { if (li.u != 2) a() }

ite = 0, mo = mou + "down"
arr = ar(3, 3)

 rou = () => {
  // contp = new AbortController()
  cont = new AbortController()
  sig = { signal: cont.signal }
  // 3 p ids + li.p
  modo('.' + li.o).forEach(el => {
      el.addEventListener(
  mo, (
  // event, callback fn, not 2, line
) => { eap(), 
  controller.abort() // remove listener
//  k = el, console.log('li1', li, el, k)

  modo('#tr > rect').forEach(tre => {
      tre.addEventListener(
  mo, () => {
    // console.log('lim2', li, el, k)
    trf(tre, el) }, sig )
  // , console.log('li1', li, el, tre)
  // tre.t = tre
} ) }, sig ) } ) }, rou() </script> </body> </html>